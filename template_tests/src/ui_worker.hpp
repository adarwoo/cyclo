#ifndef ui_worker_hpp__included
#define ui_worker_hpp__included
/*
 * UI Woker
 *
 * Created: 29/06/2021 21:26:21
 * Author : software@arreckx.com
 */
#include "asf.h"

#include "fx.hpp"
#include "msg_defs.hpp"

#include "etl/limits.h"
#include "etl/optional.h"

#include <cstdio>

using namespace rtos::tick;

const gfx_mono_color_t PROGMEM logo_header[] = {
   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3f,0xf,0x7,0x7,0x3,0x1,0x1,0x3,0x3,0x3,0x1,0x1,0x1,0x3,0x3,0xf,0xff,0xff,
   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,0x7f,0x3f,0x3f,0x1f,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe0,0xe0,0xf0,0xf0,0xf0,0xfc,0xff,0xff,
   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,0x3f,0x3f,0x1f,0x1f,0x7,0x3,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0,0xe0,0xe0,0xc0,0x80,0x80,0x0,0x3,0x87,0xff,0xff,0xff,0xff,0xff,0xff,
   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3f,0x3,0x1,0x0,0x0,0x0,0xf8,0xfc,0x8e,0x87,0x87,0x87,0x8f,0xfe,0xfc,0x0,0x0,0x0,0x0,0x0,0x80,0xc0,0x0,0x0,0x3f,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
   0xff,0xff,0xc7,0xf1,0xf1,0xf0,0xe0,0xc0,0xc0,0x80,0x80,0x0,0x0,0x0,0x0,0xf,0xf,0x1,0x1,0x1,0x1,0x1,0xf,0xf,0x0,0x0,0x0,0x7c,0xfe,0xff,0xff,0xff,0xfe,0xfc,0xfc,0xfc,0xfc,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf3,0x0,0x0,0x0,0x0,0x80,0xe0,0xf8,0xf8,0xf8,0xf8,0xe0,0x0,0x0,0x0,0x0,0xc0,0xf0,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3,0x0,0x0,0x0,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x0,0x0,0x0,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
   0xff,0xff,0xff,0xff,0xff,0xff,0x9f,0x8f,0x87,0xc0,0xe0,0xc0,0x80,0x87,0xc7,0xc7,0xcf,0xef,0xdf,0xe7,0xe3,0xe0,0xf0,0xf0,0xf1,0xe1,0xe3,0xe3,0xf7,0xf7,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
};


enum class quadrant_t : uint8_t
{
   none,
   prog = 1,
   activity,
   counter,
   info,
   stop
};

uint8_t operator*(const quadrant_t q)
   { return static_cast<uint8_t>(q) - 1; }

inline quadrant_t operator++(quadrant_t &q, int)
{
   quadrant_t retval = q;
   uint8_t iq = static_cast<uint8_t>(q);
   q = static_cast<quadrant_t>(++iq);
   
   if (q == quadrant_t::stop)
   {
      q = quadrant_t::prog;
   }
   
   return retval; 
}

inline quadrant_t operator--(quadrant_t &q, int)
{
   quadrant_t retval = q;
   uint8_t iq = static_cast<uint8_t>(q);
   q = static_cast<quadrant_t>(--iq);
   
   if (q == quadrant_t::none)
   {
      q = quadrant_t::info;
   }
   
   return retval;
}


enum class pgm_t : uint8_t
{
   P_USB,
   P_1,
   P_2,
   P_3,
   P_4,
   P_5,
   P_6,
   P_7,
   P_8,
   P_9,
   STOP
};

using cycle_counter_t = uint16_t;

enum class contact_cfg_t : uint8_t
{
   tdb,
   no,
   nc
};

enum class contact_state_t : uint8_t
{
   opened,
   closed
};


// On UI timer
//
class UIWorker : public fx::Worker<UIWorker,
   fx::DispatcherStarted, 
   msg::Keypad, 
   msg::NoNcUpdate, 
   msg::EndOfSplash>
{
   // Keep references to the system state machine
   cycle_counter_t counter;
   pgm_t program;
   contact_cfg_t contact;
   contact_state_t state;

   quadrant_t current_selection, previous_selection;
   etl::optional<bool> is_no;
   bool endOfSplash;
   
   // Create a timer
   class Splash_timer : public rtos::Timer<typestring_is("tsplash")>
   {
   public:
      Splash_timer() : rtos::Timer<typestring_is("tsplash")>(1.5_s) {}
   protected:   
      virtual void run() override
      {
         auto msg = msg::EndOfSplash {};
         fx::publish(msg);
      }
   } splash_timer;
   
public:
   explicit UIWorker() : counter{0}, program{pgm_t::P_USB}, endOfSplash {false}
   {
      gfx_mono_init();
      
      current_selection = previous_selection = quadrant_t::none;
   }
   
   void on_receive(const fx::DispatcherStarted &msg)
   {
      draw_splash();
      splash_timer.start();
   }
   
   void on_receive(const msg::EndOfSplash &msg)
   {
      // Clear using the low level API
      ssd1306_init();
      gfx_mono_init();
      
      endOfSplash = true;
      draw_box(quadrant_t::counter);
      draw_counter();
      
      if (is_no.has_value())
      {
         draw_nonc(*is_no);   
      }
   }

   void on_receive(const msg::Keypad &msg)
   {
      switch (msg.key_code)
      {
         case KEY_UP:
            previous_selection = current_selection--;
            draw_cursor(previous_selection, current_selection);
            break;
         case KEY_DOWN:
            previous_selection = current_selection++;
            draw_cursor(previous_selection, current_selection);
            break;
         case KEY_SELECT:
            ++counter;
            draw_counter();
            break;
         default:
            assert(0);
      }
      
   }
   
   void on_receive(const msg::NoNcUpdate &msg)
   {
      is_no = msg.is_no;
      
      if (endOfSplash)
      {
         draw_nonc(*is_no);
      }
   }

protected:

   void update_cycle_counter(cycle_counter_t newCount)
   {

   }
   
   void draw()
   {
      for ( uint8_t q=(*quadrant_t::none)+1; q<*quadrant_t::stop; ++q )
      {
         draw((quadrant_t)q);
      }
   }

   void draw(const quadrant_t qs)
   {
      draw_box(qs);
      
      switch(qs)
      {
         case quadrant_t::prog:     draw_prog();     break;
         case quadrant_t::activity: draw_activity(); break;
         case quadrant_t::counter:  draw_counter();  break;
         case quadrant_t::info:     draw_info();     break;
         default:
         assert(0);
      }
   }

   void draw_splash()
   {
      struct gfx_mono_bitmap logo_bm = {
         .width = 48,
         .height = 64,
         .type=GFX_MONO_BITMAP_PROGMEM,
         (gfx_mono_color_t*)logo_header
      };

      gfx_mono_put_bitmap(&logo_bm, 0, 0);
   }
   
   void draw_prog()
   {

   }

   void draw_activity()
   {

   }

   void draw_counter()
   {
      static char counterString[6];
      snprintf(counterString, sizeof(counterString), "%.5u", this->counter);
      gfx_mono_draw_string(counterString, 15, 36, &sysfont);
   }
   
   void draw_nonc(bool isNo )
   {
      gfx_mono_draw_string(isNo ? "NO" : "NC", 34, 52, &sysfont);
   }

   void draw_info()
   {

   }
   
   void draw_box(const quadrant_t q)
   {
      gfx_mono_generic_draw_rect(0, 0, 48, 64, GFX_PIXEL_SET);
      gfx_mono_draw_horizontal_line(0, 15, 48, GFX_PIXEL_SET);
      gfx_mono_draw_horizontal_line(0, 31, 48, GFX_PIXEL_SET);
      gfx_mono_draw_horizontal_line(0, 47, 48, GFX_PIXEL_SET);
   }
   
   void draw_selection()
   {
      
   }
   
   void draw_cursor(quadrant_t from, quadrant_t to)
   {
      auto q2y = [](quadrant_t q) {
         return (*q) * 16;
      };
      
      
      if ( from != quadrant_t::none )
      {
         gfx_coord_t y = q2y(from) + 3;

         gfx_mono_draw_filled_rect(3, y, 9, 9, GFX_PIXEL_CLR);
      }
      
      if ( to != quadrant_t::none )
      {
         gfx_coord_t y = q2y(to) + 3;

         gfx_mono_draw_line(3, y, 11, y+4, GFX_PIXEL_SET);
         gfx_mono_draw_line(11, y+4, 3, y+8, GFX_PIXEL_SET);
         gfx_mono_draw_line(3, y+8, 3, y, GFX_PIXEL_SET);
      }
   }
   
};


#endif // ndef ui_worker_hpp__included
